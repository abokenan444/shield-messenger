//! Quote generation for NLx402 payment protocol
//!
//! Quotes are generated by the payee and contain all information needed
//! to make a payment. The quote hash is embedded in the transaction memo
//! for replay protection.

use chrono::Utc;
use serde::{Deserialize, Serialize};
use sha3::{Digest, Sha3_256};
use thiserror::Error;

use super::{DEFAULT_QUOTE_EXPIRY_SECS, MEMO_PREFIX};

#[derive(Error, Debug)]
pub enum QuoteError {
    #[error("Quote has expired")]
    Expired,
    #[error("Invalid amount: {0}")]
    InvalidAmount(String),
    #[error("Invalid recipient address")]
    InvalidRecipient,
    #[error("Serialization error: {0}")]
    SerializationError(String),
    #[error("Quote parsing error: {0}")]
    ParseError(String),
}

pub type Result<T> = std::result::Result<T, QuoteError>;

/// A payment quote containing all necessary payment information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentQuote {
    /// Unique quote identifier (UUID)
    pub quote_id: String,
    /// Recipient wallet address (Solana/Zcash)
    pub recipient: String,
    /// Amount in smallest unit (lamports/zatoshis)
    pub amount: u64,
    /// Token type (SOL, ZEC, USDC, etc.)
    pub token: String,
    /// Human-readable description
    pub description: Option<String>,
    /// Quote creation timestamp (Unix seconds)
    pub created_at: i64,
    /// Quote expiration timestamp (Unix seconds)
    pub expires_at: i64,
    /// Sender's handle (for reference)
    pub sender_handle: Option<String>,
    /// Recipient's handle (for reference)
    pub recipient_handle: Option<String>,
}

impl PaymentQuote {
    /// Check if this quote has expired
    pub fn is_expired(&self) -> bool {
        let now = Utc::now().timestamp();
        now > self.expires_at
    }

    /// Calculate the SHA3-256 hash of this quote
    /// This hash is embedded in the transaction memo for verification
    pub fn hash(&self) -> [u8; 32] {
        let mut hasher = Sha3_256::new();

        // Hash deterministic fields in order
        hasher.update(self.quote_id.as_bytes());
        hasher.update(self.recipient.as_bytes());
        hasher.update(self.amount.to_le_bytes());
        hasher.update(self.token.as_bytes());
        hasher.update(self.created_at.to_le_bytes());
        hasher.update(self.expires_at.to_le_bytes());

        let result = hasher.finalize();
        let mut hash = [0u8; 32];
        hash.copy_from_slice(&result);
        hash
    }

    /// Get the hash as a hex string (first 16 bytes for memo brevity)
    pub fn hash_hex(&self) -> String {
        let hash = self.hash();
        // Use first 16 bytes (32 hex chars) to keep memo size reasonable
        hex::encode(&hash[..16])
    }

    /// Generate the memo string for blockchain transaction
    pub fn to_memo(&self) -> String {
        format!("{}{}", MEMO_PREFIX, self.hash_hex())
    }

    /// Serialize quote to JSON
    pub fn to_json(&self) -> Result<String> {
        serde_json::to_string(self).map_err(|e| QuoteError::SerializationError(e.to_string()))
    }

    /// Deserialize quote from JSON
    pub fn from_json(json: &str) -> Result<Self> {
        serde_json::from_str(json).map_err(|e| QuoteError::ParseError(e.to_string()))
    }
}

/// Create a new payment quote with default 24-hour expiry
///
/// # Arguments
/// * `recipient` - Recipient wallet address
/// * `amount` - Amount in smallest unit (lamports/zatoshis)
/// * `token` - Token type (SOL, ZEC, USDC)
/// * `description` - Optional human-readable description
/// * `sender_handle` - Optional sender's handle
/// * `recipient_handle` - Optional recipient's handle
///
/// # Returns
/// A new PaymentQuote with generated ID and expiration
pub fn create_quote(
    recipient: &str,
    amount: u64,
    token: &str,
    description: Option<&str>,
    sender_handle: Option<&str>,
    recipient_handle: Option<&str>,
) -> Result<PaymentQuote> {
    create_quote_with_expiry(
        recipient,
        amount,
        token,
        description,
        sender_handle,
        recipient_handle,
        DEFAULT_QUOTE_EXPIRY_SECS,
    )
}

/// Create a new payment quote with custom expiry time
///
/// # Arguments
/// * `recipient` - Recipient wallet address
/// * `amount` - Amount in smallest unit (lamports/zatoshis)
/// * `token` - Token type (SOL, ZEC, USDC)
/// * `description` - Optional human-readable description
/// * `sender_handle` - Optional sender's handle
/// * `recipient_handle` - Optional recipient's handle
/// * `expiry_secs` - Custom expiry time in seconds
///
/// # Returns
/// A new PaymentQuote with generated ID and custom expiration
pub fn create_quote_with_expiry(
    recipient: &str,
    amount: u64,
    token: &str,
    description: Option<&str>,
    sender_handle: Option<&str>,
    recipient_handle: Option<&str>,
    expiry_secs: u64,
) -> Result<PaymentQuote> {
    if recipient.is_empty() {
        return Err(QuoteError::InvalidRecipient);
    }

    if amount == 0 {
        return Err(QuoteError::InvalidAmount(
            "Amount must be greater than 0".into(),
        ));
    }

    let now = Utc::now();
    let quote_id = uuid::Uuid::new_v4().to_string();

    Ok(PaymentQuote {
        quote_id,
        recipient: recipient.to_string(),
        amount,
        token: token.to_string(),
        description: description.map(|s| s.to_string()),
        created_at: now.timestamp(),
        expires_at: now.timestamp() + expiry_secs as i64,
        sender_handle: sender_handle.map(|s| s.to_string()),
        recipient_handle: recipient_handle.map(|s| s.to_string()),
    })
}

/// Parse a quote hash from a transaction memo
///
/// # Arguments
/// * `memo` - Transaction memo string
///
/// # Returns
/// The quote hash hex string if found
pub fn parse_quote_from_memo(memo: &str) -> Option<String> {
    if memo.starts_with(MEMO_PREFIX) {
        Some(memo[MEMO_PREFIX.len()..].to_string())
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_quote() {
        let quote = create_quote(
            "So1anaAddress123456789",
            1_000_000_000, // 1 SOL in lamports
            "SOL",
            Some("Payment for services"),
            Some("alice"),
            Some("bob"),
        )
        .unwrap();

        assert!(!quote.quote_id.is_empty());
        assert_eq!(quote.recipient, "So1anaAddress123456789");
        assert_eq!(quote.amount, 1_000_000_000);
        assert_eq!(quote.token, "SOL");
        assert!(!quote.is_expired());
    }

    #[test]
    fn test_quote_hash() {
        let quote = create_quote("TestRecipient123", 500_000, "USDC", None, None, None).unwrap();

        let hash1 = quote.hash();
        let hash2 = quote.hash();

        // Same quote should produce same hash
        assert_eq!(hash1, hash2);
        assert_eq!(hash1.len(), 32);
    }

    #[test]
    fn test_quote_memo() {
        let quote = create_quote("TestRecipient", 1000, "SOL", None, None, None).unwrap();

        let memo = quote.to_memo();
        assert!(memo.starts_with("NLx402:"));
        assert_eq!(memo.len(), 7 + 32); // prefix + 16 bytes as hex
    }

    #[test]
    fn test_parse_memo() {
        let memo = "NLx402:abc123def456789012345678901234";
        let hash = parse_quote_from_memo(memo);
        assert!(hash.is_some());
        assert_eq!(hash.unwrap(), "abc123def456789012345678901234");
    }

    #[test]
    fn test_quote_json_roundtrip() {
        let quote = create_quote(
            "TestRecipient",
            1000,
            "ZEC",
            Some("Test payment"),
            Some("sender"),
            Some("recipient"),
        )
        .unwrap();

        let json = quote.to_json().unwrap();
        let parsed = PaymentQuote::from_json(&json).unwrap();

        assert_eq!(quote.quote_id, parsed.quote_id);
        assert_eq!(quote.recipient, parsed.recipient);
        assert_eq!(quote.amount, parsed.amount);
    }

    #[test]
    fn test_invalid_quote() {
        // Empty recipient
        let result = create_quote("", 1000, "SOL", None, None, None);
        assert!(result.is_err());

        // Zero amount
        let result = create_quote("recipient", 0, "SOL", None, None, None);
        assert!(result.is_err());
    }
}
