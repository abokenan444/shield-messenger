/**
 * WASM Bridge — typed interface to the Rust core compiled to WebAssembly
 *
 * This module loads the compiled WASM binary and exposes all cryptographic
 * operations with TypeScript types. All crypto runs in Rust — zero JS crypto.
 *
 * Build the WASM module:
 *   cd shield-messenger-core
 *   cargo build --target wasm32-unknown-unknown --features wasm --release
 *   wasm-bindgen --out-dir ../web/src/wasm --target web \
 *     target/wasm32-unknown-unknown/release/securelegion.wasm
 */

// The WASM module types (matches wasm.rs exports via wasm-bindgen)
interface SecureLegionWasm {
  // Identity (Ed25519)
  generate_identity_keypair(): string; // JSON
  derive_ed25519_public_key(privateKeyB64: string): string;

  // Key Exchange (X25519)
  generate_x25519_keypair(): string; // JSON
  x25519_derive_shared_secret(ourPrivB64: string, theirPubB64: string): string;

  // Encryption (XChaCha20-Poly1305)
  generate_encryption_key(): string;
  encrypt_message(plaintext: string, keyB64: string): string;
  decrypt_message(ciphertextB64: string, keyB64: string): string;

  // Forward Secrecy
  derive_root_key(sharedSecretB64: string): string;
  evolve_chain_key(chainKeyB64: string): string;
  encrypt_message_evolved(plaintext: string, chainKeyB64: string, sequence: bigint): string;
  decrypt_message_evolved(ciphertextB64: string, chainKeyB64: string, expectedSeq: bigint): string;

  // Signing (Ed25519)
  sign_message(messageB64: string, privateKeyB64: string): string;
  verify_signature(messageB64: string, signatureB64: string, publicKeyB64: string): boolean;

  // Hashing (Argon2id)
  hash_password(password: string): string;
  verify_password(password: string, hash: string): boolean;
  derive_key_from_password(password: string, saltB64: string): string;
  generate_salt(): string;

  // Post-Quantum
  generate_hybrid_keypair(): string; // JSON
  hybrid_encapsulate(recipientX25519PubB64: string, recipientKyberPubB64: string): string;
  hybrid_decapsulate(
    x25519EphPubB64: string,
    kyberCtB64: string,
    ourX25519SecB64: string,
    ourKyberSecB64: string,
  ): string;

  // Protocol
  create_contact_card(pubKeyB64: string, handle: string, onion: string, solana: string): string;
  sign_contact_card(cardJson: string, privKeyB64: string): string;
  serialize_message(msgJson: string): string;
  deserialize_message(dataB64: string): string;

  // Utility
  get_version(): string;
}

let wasmModule: SecureLegionWasm | null = null;
let initPromise: Promise<void> | null = null;

/**
 * Load and initialize the WASM module.
 * Safe to call multiple times — only loads once.
 */
export async function initWasm(): Promise<void> {
  if (wasmModule) return;

  if (initPromise) {
    await initPromise;
    return;
  }

  initPromise = (async () => {
    try {
      // Dynamic import of the wasm-bindgen generated module
      // @ts-expect-error — WASM module is generated by wasm-bindgen build step
      const wasm = await import('../../wasm/securelegion.js');
      await wasm.default(); // Initialize WASM
      wasmModule = wasm as unknown as SecureLegionWasm;
      console.log('[SL] WASM core loaded — version:', wasmModule.get_version());
    } catch (e) {
      console.error('[SL] Failed to load WASM module:', e);
      throw new Error(
        'Failed to initialize Shield Messenger core. ' +
        'Build the WASM module first: see web/README.md',
      );
    }
  })();

  await initPromise;
}

/**
 * Get the loaded WASM module (throws if not initialized)
 */
function getWasm(): SecureLegionWasm {
  if (!wasmModule) {
    throw new Error('WASM not initialized — call initWasm() first');
  }
  return wasmModule;
}

/** Check if WASM is loaded */
export function isWasmReady(): boolean {
  return wasmModule !== null;
}

// ─────────────────── Typed Wrappers ───────────────────

export interface Keypair {
  publicKey: string; // base64
  privateKey: string; // base64
}

export interface HybridKeypair {
  x25519PublicKey: string;
  x25519SecretKey: string;
  kyberPublicKey: string;
  kyberSecretKey: string;
}

export interface EncryptionEvolutionResult {
  ciphertext: string; // base64
  evolvedChainKey: string; // base64
}

export interface DecryptionEvolutionResult {
  plaintext: string;
  evolvedChainKey: string; // base64
}

export interface HybridEncapsulation {
  x25519EphemeralPublic: string;
  kyberCiphertext: string;
  sharedSecret: string;
}

// ─── Identity ───

export function generateIdentityKeypair(): Keypair {
  return JSON.parse(getWasm().generate_identity_keypair());
}

export function deriveEd25519PublicKey(privateKeyB64: string): string {
  return getWasm().derive_ed25519_public_key(privateKeyB64);
}

// ─── Key Exchange ───

export function generateX25519Keypair(): Keypair {
  return JSON.parse(getWasm().generate_x25519_keypair());
}

export function x25519DeriveSharedSecret(ourPrivB64: string, theirPubB64: string): string {
  return getWasm().x25519_derive_shared_secret(ourPrivB64, theirPubB64);
}

// ─── Encryption ───

export function generateEncryptionKey(): string {
  return getWasm().generate_encryption_key();
}

export function encryptMessage(plaintext: string, keyB64: string): string {
  return getWasm().encrypt_message(plaintext, keyB64);
}

export function decryptMessage(ciphertextB64: string, keyB64: string): string {
  return getWasm().decrypt_message(ciphertextB64, keyB64);
}

// ─── Forward Secrecy ───

export function deriveRootKey(sharedSecretB64: string): string {
  return getWasm().derive_root_key(sharedSecretB64);
}

export function evolveChainKey(chainKeyB64: string): string {
  return getWasm().evolve_chain_key(chainKeyB64);
}

export function encryptMessageEvolved(
  plaintext: string,
  chainKeyB64: string,
  sequence: number,
): EncryptionEvolutionResult {
  return JSON.parse(getWasm().encrypt_message_evolved(plaintext, chainKeyB64, BigInt(sequence)));
}

export function decryptMessageEvolved(
  ciphertextB64: string,
  chainKeyB64: string,
  expectedSequence: number,
): DecryptionEvolutionResult {
  return JSON.parse(getWasm().decrypt_message_evolved(ciphertextB64, chainKeyB64, BigInt(expectedSequence)));
}

// ─── Signing ───

export function signMessage(messageB64: string, privateKeyB64: string): string {
  return getWasm().sign_message(messageB64, privateKeyB64);
}

export function verifySignature(messageB64: string, signatureB64: string, publicKeyB64: string): boolean {
  return getWasm().verify_signature(messageB64, signatureB64, publicKeyB64);
}

// ─── Hashing ───

export function hashPassword(password: string): string {
  return getWasm().hash_password(password);
}

export function verifyPassword(password: string, hash: string): boolean {
  return getWasm().verify_password(password, hash);
}

export function deriveKeyFromPassword(password: string, saltB64: string): string {
  return getWasm().derive_key_from_password(password, saltB64);
}

export function generateSalt(): string {
  return getWasm().generate_salt();
}

// ─── Post-Quantum ───

export function generateHybridKeypair(): HybridKeypair {
  return JSON.parse(getWasm().generate_hybrid_keypair());
}

export function hybridEncapsulate(
  recipientX25519PubB64: string,
  recipientKyberPubB64: string,
): HybridEncapsulation {
  return JSON.parse(getWasm().hybrid_encapsulate(recipientX25519PubB64, recipientKyberPubB64));
}

export function hybridDecapsulate(
  x25519EphPubB64: string,
  kyberCtB64: string,
  ourX25519SecB64: string,
  ourKyberSecB64: string,
): string {
  return getWasm().hybrid_decapsulate(x25519EphPubB64, kyberCtB64, ourX25519SecB64, ourKyberSecB64);
}

// ─── Protocol ───

export function createContactCard(pubKeyB64: string, handle: string, onion: string, solana: string): string {
  return getWasm().create_contact_card(pubKeyB64, handle, onion, solana);
}

export function signContactCard(cardJson: string, privKeyB64: string): string {
  return getWasm().sign_contact_card(cardJson, privKeyB64);
}

export function serializeMessage(msgJson: string): string {
  return getWasm().serialize_message(msgJson);
}

export function deserializeMessage(dataB64: string): string {
  return getWasm().deserialize_message(dataB64);
}

// ─── Version ───

export function getVersion(): string {
  return getWasm().get_version();
}
